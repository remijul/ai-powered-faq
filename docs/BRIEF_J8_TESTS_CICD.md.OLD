# Brief J8 - Tests et CI/CD

## Objectif de la journÃ©e

Mettre en place une stratÃ©gie de tests automatisÃ©s et une chaÃ®ne d'intÃ©gration continue (CI/CD) pour garantir la qualitÃ© du code et automatiser les dÃ©ploiements.

---

## Contexte pÃ©dagogique

Les tests automatisÃ©s et la CI/CD sont des pratiques essentielles en dÃ©veloppement professionnel. Ils permettent de :

- **DÃ©tecter les bugs** avant la mise en production
- **Documenter** le comportement attendu du code
- **Automatiser** les tÃ¢ches rÃ©pÃ©titives
- **Gagner en confiance** lors des modifications

### CompÃ©tences visÃ©es (REAC)

| CompÃ©tence | Description |
|------------|-------------|
| C12 | Programmer les tests automatisÃ©s d'un modÃ¨le d'IA |
| C18 | Automatiser les phases de tests via intÃ©gration continue |
| C19 | CrÃ©er un processus de livraison continue |

---

## Les types de tests

### Pyramide des tests

```
        â–²
       /â–ˆ\         Tests E2E (End-to-End)
      /â–ˆâ–ˆâ–ˆ\        â†’ Peu nombreux, lents, coÃ»teux
     /â–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\       
    /â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\      Tests d'intÃ©gration
   /â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\     â†’ API, base de donnÃ©es
  /â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\    
 /â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\   Tests unitaires
/â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ\  â†’ Nombreux, rapides, isolÃ©s
```

| Type | Scope | Exemple projet FAQ |
|------|-------|-------------------|
| **Unitaire** | Une fonction | `test_normalize_text()` |
| **IntÃ©gration** | Plusieurs composants | `test_strategy_b_answer()` |
| **E2E** | SystÃ¨me complet | `test_api_answer_endpoint()` |

---

## Framework : pytest

### Installation

```bash
pip install pytest pytest-cov pytest-asyncio httpx
```

### Structure des tests

```txt
tests/
â”œâ”€â”€ __init__.py
â”œâ”€â”€ conftest.py            # Fixtures partagÃ©es et auto-disponibles partout
â”œâ”€â”€ unit/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_normalize.py  # Peut utiliser les fixtures de conftest.py
â”‚   â””â”€â”€ test_faq_response.py
â”œâ”€â”€ integration/
â”‚   â”œâ”€â”€ __init__.py
â”‚   â”œâ”€â”€ test_strategy_a.py
â”‚   â”œâ”€â”€ test_strategy_b.py # Peut utiliser les fixtures de conftest.py
â”‚   â””â”€â”€ test_strategy_c.py
â””â”€â”€ api/
    â”œâ”€â”€ __init__.py
    â””â”€â”€ test_endpoints.py
```

---

## ImplÃ©mentation des tests

### Tests unitaires (exemple)

```python
# exemple de tests unitaires pour valider une fonction `normalize_text()` prÃ©sente dans src/utils/text 
# la fonction `normalize_text()` permettant de "normaliser" une chaine de caractÃ¨re (conversion en minuscule, suppression des accents et ponctuation, etc.)
from src.utils.text import normalize_text

def test_normalize_lowercase():
    """VÃ©rifie la conversion en minuscules."""
    assert normalize_text("BONJOUR") == "bonjour"

def test_normalize_accents():
    """VÃ©rifie la suppression des accents."""
    assert normalize_text("Ã©lÃ©phant") == "elephant"

def test_normalize_punctuation():
    """VÃ©rifie la suppression de la ponctuation."""
    assert normalize_text("Bonjour, monde!") == "bonjour monde"
```

### Tests d'intÃ©gration (stratÃ©gies)

```python
# tests/integration/test_strategy_b.py
import pytest
from src.strategies.strategy_b_rag import StrategyBRAG

@pytest.fixture
def strategy(faq_base):  # â† injecte la fixture de conftest.py
    """Fixture : instance de la stratÃ©gie B."""
    return StrategyBRAG(faq_base=faq_base)

def test_answer_returns_faq_response(strategy):
    """VÃ©rifie que la rÃ©ponse est un FAQResponse."""
    result = strategy.answer("Test question")
    assert hasattr(result, 'answer')
    assert hasattr(result, 'confidence')

def test_answer_confidence_range(strategy):
    """VÃ©rifie que la confiance est entre 0 et 1."""
    result = strategy.answer("Test question")
    assert 0.0 <= result.confidence <= 1.0

def test_hors_sujet_detection(strategy):
    """VÃ©rifie la dÃ©tection des questions hors sujet."""
    result = strategy.answer("Quelle est la capitale de l'Australie ?")
    assert "pas trouvÃ©" in result.answer.lower() or result.confidence < 0.5
```

**Explication** : Une **fixture** est une fonction qui prÃ©pare des donnÃ©es ou des objets nÃ©cessaires aux tests. Le dÃ©corateur `@pytest.fixture` indique Ã  `pytest` que cette fonction n'est pas un test, mais un **fournisseur de ressources**. Quand un test dÃ©clare un paramÃ¨tre portant le mÃªme nom que la fixture, `pytest` l'injecte automatiquement â€” c'est l'**injection de dÃ©pendances**.

### Tests API (endpoints)

```python
# tests/api/test_endpoints.py
import pytest
from httpx import AsyncClient
from src.api.main import app

@pytest.mark.asyncio
async def test_health_endpoint():
    """VÃ©rifie que /health retourne 200."""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.get("/health")
    assert response.status_code == 200
    assert response.json()["status"] == "ok"

@pytest.mark.asyncio
async def test_answer_endpoint():
    """VÃ©rifie que /api/v1/answer fonctionne."""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post(
            "/api/v1/answer",
            json={"question": "Comment obtenir un acte de naissance ?"}
        )
    assert response.status_code == 200
    assert "answer" in response.json()

@pytest.mark.asyncio
async def test_answer_empty_question():
    """VÃ©rifie le rejet des questions vides."""
    async with AsyncClient(app=app, base_url="http://test") as client:
        response = await client.post(
            "/api/v1/answer",
            json={"question": ""}
        )
    assert response.status_code == 422  # Validation error
```

**Explication** : Ce dÃ©corateur indique Ã  pytest que le test est une **coroutine asynchrone** (fonction `async def`). Sans ce marqueur, pytest ne sait pas qu'il doit exÃ©cuter la fonction avec une boucle d'Ã©vÃ©nements asyncio. NÃ©cessite le plugin `pytest-asyncio`.

### Fixtures partagÃ©es

`conftest.py` est un fichier **spÃ©cial** reconnu automatiquement par `pytest`. Les fixtures qu'il contient sont **injectÃ©es sans import explicite** dans tous les tests du mÃªme rÃ©pertoire et sous-rÃ©pertoires.

```python
# tests/conftest.py
import pytest
import json
from pathlib import Path

# DÃ©claration d'un Ã©lÃ©ment (donnÃ©es / objets) nÃ©cessaires aux tests Ã  venir : ici la base faq rÃ©utilisable lors des tests auto.
@pytest.fixture
def faq_base():
    """Charge la base FAQ pour les tests."""
    path = Path(__file__).parent.parent / "data" / "faq_base.json"
    with open(path, 'r', encoding='utf-8') as f:
        return json.load(f).get("faq", [])

# DÃ©claration d'un Ã©lÃ©ment (donnÃ©es / objets) nÃ©cessaires aux tests Ã  venir : ici le golden set.
@pytest.fixture
def golden_set():
    """Charge le golden set pour les tests."""
    path = Path(__file__).parent.parent / "data" / "golden_set.json"
    with open(path, 'r', encoding='utf-8') as f:
        return json.load(f).get("golden_set", [])
```

**Pourquoi ce design ?**

| Avantage | Description |
|------|-------|
| **DRY** | Fixtures partagÃ©es, pas de duplication |
| **Scope** | Fixtures locales Ã  un dossier si besoin |
| **LisibilitÃ©** | Tests plus courts, sans imports rÃ©pÃ©titifs |

---

## ExÃ©cution des tests

### Commandes de base

```bash
# Lancer tous les tests
pytest

# Avec couverture de code
pytest --cov=src --cov-report=html

# Tests d'un dossier spÃ©cifique
pytest tests/unit/

# Tests avec nom contenant "strategy"
pytest -k "strategy"

# Mode verbose
pytest -v

# ArrÃªter au premier Ã©chec
pytest -x
```

### Rapport de couverture

```bash
pytest --cov=src --cov-report=html
# Ouvrir htmlcov/index.html dans un navigateur
```

---

## CI/CD avec GitHub Actions

### Concept

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Push   â”‚â”€â”€â”€â”€â–¶â”‚  Build  â”‚â”€â”€â”€â”€â–¶â”‚  Test   â”‚â”€â”€â”€â”€â–¶â”‚ Deploy  â”‚
â”‚  Code   â”‚     â”‚         â”‚     â”‚         â”‚     â”‚         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                          Pipeline CI/CD
```

### Fichiers workflow

En premiÃ¨re Ã©tape de construction du worfklow, il est pertinent de commencer uniquement par l'aspect CI du pipeline qui intÃ¨gre principalement les tests automatisÃ©s, sans build ni deploy.  
Dans un 2Ã¨me temps, les phases de build et dÃ©ploy seront intÃ©grÃ©es pour constituer le pipeline CI/CD intÃ©gral.

#### Pipeline  - CI (step 1)

```yaml
# .github/workflows/ci.yml
name: CI Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov
      
      - name: Run tests
        env:
          HF_API_TOKEN: ${{ secrets.HF_API_TOKEN }}
        run: |
          pytest --cov=src --cov-report=xml
      
      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.xml

  lint:
    runs-on: ubuntu-latest
    
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install linters
        run: pip install flake8 black
      
      - name: Check formatting
        run: black --check src/
      
      - name: Lint code
        run: flake8 src/
```

#### Pipeline  - CI/CD (step 2)

```yaml
# .github/workflows/cicd.yml
name: CI/CD Pipeline

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  # ============================================================
  # JOB 1 : LINT - VÃ©rification du style de code
  # ============================================================
  lint:
    name: ğŸ” Lint & Format
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install linters
        run: pip install flake8 black isort
      
      - name: Check formatting (black)
        run: black --check src/ tests/
      
      - name: Check imports (isort)
        run: isort --check-only src/ tests/
      
      - name: Lint code (flake8)
        run: flake8 src/ tests/ --max-line-length=100

  # ============================================================
  # JOB 2 : BUILD - Construction de l'application
  # ============================================================
  build:
    name: ğŸ”¨ Build
    runs-on: ubuntu-latest
    needs: lint                      # Attend que lint soit OK
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
      
      - name: Verify imports
        run: |
          python -c "from src.strategies.strategy_a_llm import StrategyALLM"
          python -c "from src.strategies.strategy_b_rag import StrategyBRAG"
          python -c "from src.strategies.strategy_c_qa import StrategyCQA"
          python -c "from src.api.main import app"
          echo "âœ… All imports successful"
      
      # Optionnel : construire une image Docker
      - name: Build Docker image
        run: |
          docker build -t faq-api:${{ github.sha }} .
        if: github.ref == 'refs/heads/main'

  # ============================================================
  # JOB 3 : TEST - ExÃ©cution des tests
  # ============================================================
  test:
    name: ğŸ§ª Test
    runs-on: ubuntu-latest
    needs: build                     # Attend que build soit OK
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.10'
      
      - name: Install dependencies
        run: |
          pip install -r requirements.txt
          pip install pytest pytest-cov pytest-asyncio httpx
      
      - name: Run unit tests
        run: pytest tests/unit/ -v
      
      - name: Run integration tests
        env:
          HF_API_TOKEN: ${{ secrets.HF_API_TOKEN }}
        run: pytest tests/integration/ -v
      
      - name: Run API tests
        run: pytest tests/api/ -v
      
      - name: Generate coverage report
        env:
          HF_API_TOKEN: ${{ secrets.HF_API_TOKEN }}
        run: pytest --cov=src --cov-report=xml --cov-report=html
      
      - name: Upload coverage to Codecov
        uses: codecov/codecov-action@v3
        with:
          files: ./coverage.xml
          fail_ci_if_error: false

  # ============================================================
  # JOB 4 : DEPLOY - DÃ©ploiement (uniquement sur main)
  # ============================================================
  deploy:
    name: ğŸš€ Deploy
    runs-on: ubuntu-latest
    needs: test                      # Attend que test soit OK
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Deploy to production
        env:
          DEPLOY_TOKEN: ${{ secrets.DEPLOY_TOKEN }}
        run: |
          echo "ğŸš€ Deploying to production..."
          # Exemples de commandes de dÃ©ploiement :
          # 
          # Heroku :
          # heroku container:push web --app mon-app
          # heroku container:release web --app mon-app
          #
          # Railway :
          # railway up
          #
          # SSH vers serveur :
          # ssh user@server "cd /app && git pull && systemctl restart faq-api"
          #
          echo "âœ… Deployment complete"
      
      - name: Notify success
        run: |
          echo "::notice::Deployment successful! ğŸ‰"
```

---

### Visualisation du pipeline CI/CD

```txt
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  LINT   â”‚â”€â”€â”€â”€â–¶â”‚  BUILD  â”‚â”€â”€â”€â”€â–¶â”‚  TEST   â”‚â”€â”€â”€â”€â–¶â”‚ DEPLOY  â”‚
â”‚         â”‚     â”‚         â”‚     â”‚         â”‚     â”‚         â”‚
â”‚ black   â”‚     â”‚ install â”‚     â”‚ pytest  â”‚     â”‚ (main   â”‚
â”‚ flake8  â”‚     â”‚ verify  â”‚     â”‚ coverageâ”‚     â”‚  only)  â”‚
â”‚ isort   â”‚     â”‚ docker? â”‚     â”‚         â”‚     â”‚         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚               â”‚               â”‚               â”‚
     â”‚    needs      â”‚    needs      â”‚    needs      â”‚
     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Configuration des secrets GitHub

1. Aller dans **Settings** > **Secrets and variables** > **Actions**
2. Cliquer **New repository secret**
3. Ajouter `HF_API_TOKEN` avec votre clÃ© HuggingFace

---

## Travail Ã  rÃ©aliser

### Ã‰tape 1 : CrÃ©er la structure des tests

```bash
mkdir -p tests/unit tests/integration tests/api
touch tests/__init__.py tests/conftest.py
```

### Ã‰tape 2 : Ã‰crire les tests unitaires

- [ ] `test_normalize_text.py` (3+ tests)
- [ ] `test_faq_response.py` (2+ tests)

### Ã‰tape 3 : Ã‰crire les tests d'intÃ©gration

- [ ] `test_strategy_a.py` (2+ tests)
- [ ] `test_strategy_b.py` (3+ tests)
- [ ] `test_strategy_c.py` (2+ tests)

### Ã‰tape 4 : Ã‰crire les tests API

- [ ] `test_endpoints.py` (4+ tests)

### Ã‰tape 5 : Configurer GitHub Actions

- [ ] CrÃ©er `.github/workflows/ci.yml`
- [ ] Ajouter le secret `HF_API_TOKEN`
- [ ] VÃ©rifier que le pipeline passe âœ… : Ã  faire Ã  chaque modification pour vous assurer que les tests sont fonctionnels

---

## Livrables attendus

| Livrable | Description |
|----------|-------------|
| `tests/` | Suite de tests (10+ tests minimum) |
| `.github/workflows/ci.yml` | Pipeline CI/CD |
| Rapport couverture | `htmlcov/` ou badge codecov |
| Screenshot | Pipeline GitHub Actions vert |

---

## Points de vigilance

| ProblÃ¨me | Solution |
|----------|----------|
| Tests API lents | Utiliser des mocks pour les appels externes |
| Secret non disponible en CI | VÃ©rifier la configuration GitHub Secrets |
| Import errors | Ajouter `PYTHONPATH` ou `conftest.py` |
| Tests flaky (alÃ©atoires) | Ã‰viter les dÃ©pendances au temps/rÃ©seau |

---

## Pour aller plus loin

- Ajouter des tests de performance (latence max)
- ImplÃ©menter des tests de charge avec `locust`
- Configurer des notifications Slack/Discord en cas d'Ã©chec
- Ajouter un job de dÃ©ploiement automatique
